from PIL import Image, ImageDraw
import math, random
import numpy as np
import time
import Img2Gif
import threading, thread

class Controller():
    def __init__(self,starttime,total):
        self.width_h = 30
        self.height_h = 20
        self.x = 249
        self.y = 454
        self.angle = 70.0
        self.camangle = 30.0
        self.eatangle = 15.0
        self.bumper = [0, 0, 0, 0]
        self.thrown = False
        self.ballnum = 0 
        self.step = 20
        self.st = starttime
        self.total = total
        self.count=0
        self.new=0
    
    def getBallCount(self):
        return 1

    def goStraight(self,direction):
        while time.time()-self.st<self.total and sum(self.bumper)==0:
            an=self.angle/180*math.pi
            self.x -= direction*self.step * math.sin(an)
            self.y += direction*self.step * math.cos(an)
            time.sleep(1)
            print "go straight",self.x,self.y,self.angle

        """
        while sum(self.control.bumper())==1:
            #only rotate
            a=1
        """
         
    def throwBall(self):
        self.thrown = True
        
    def goTurn(self, angle):
        #print "angle : ",self.angle 
        self.angle += angle
        if self.angle > 360:
            self.angle -= 360
        elif self.angle < 0:
            self.angle += 360
        time.sleep(1)
               
    def ControlBumper(self):
        return self.bumper

    def ControlNavigation(self):
        return self.bumper
          
class Vision():
    def __init__(self,starttime,total):
        self.x = 0
        self.y = 0
        self.img = None
        
        self.HSV = [[0, 50, 0, 10, 180, 256,
                   150, 50, 0, 256, 180, 256]] * 3
        self.st = starttime
        self.total = total
                        
    def findObj(self, state):
        if state == 'r':
            return self.findCircle()
        else:
            return self.findWall(state)
        
    def findCircle(self):
        found = False  
        #print self.img
        while self.img == None and time.time()-self.st<self.total:
            #print "no img"
            pass         
           
        for i in range(len(self.img[3])):
            #print i,self.img[:3] + [self.img[3][i][:2]]
            if self.ptwithin(self.img[:3] + [self.img[3][i][:2]]):
                found = True
                break
        return found

    def findWall(self, state):                 
        if self.img[0][1] == 500 and self.img[1][1] == 500:
            return True
        else:
            return False

    def ptwithin(self, v):        
        for i in range(3):
            v[i] = np.array(v[i])
        #center,two bd lines, query pt
        if self.SameSide(v[1], v[2], v[0], v[3]):
            return True
        else:
            return False

    def SameSide(self, p1, p2, a, b):
        cp1 = np.cross(b - a, p1 - a)
        cp2 = np.cross(b - a, p2 - a)
        #print b - a,p1 - a,p2 - a,cp1,cp2,cp1*cp2 
        if cp1*cp2 <= 0 and np.dot(b - a, p1 - a)>=0and np.dot(b - a, p2 - a)>=0:
            return True
        else:
            return False

    """""" 


class Logic(threading.Thread):
    def __init__(self,starttime,total):
        threading.Thread.__init__(self)
        #self._stop = threading.Event()
        self.control = Controller(starttime,total)
        self.vision = Vision(starttime,total)
        self.states = ['r', 'b', 'y']
        self.current_st = 'r'
        self.ballcount = 0
        self.st = starttime
        self.total = total
        #self.tostop=0
    
    def run(self):   
        while  time.time() - self.st < self.total:
            self.getBall()           
            self.dumpBall()
            #print "success"
            break        
        
    def getBall(self):        
        while  time.time() - self.st < self.total and self.control.new==0:            
            self.findObj()      
            #print "step 1"                                            
            self.control.goStraight(1)
            if sum(self.control.bumper)!=0:
                self.getOutStuck()
        if self.control.new==1:
            self.ballcount+=1
            self.control.new=0
            self.current_st = 'y'
            
    def dumpBall(self):        
        while  time.time() - self.st < self.total and self.current_st == 'y':                        
            self.findObj()            
            self.control.goStraight(1)
            self.control.throwBall()    
            self.ballcount=0
            self.current_st = 'r'        
            
        
    def findObj(self):
        found = self.vision.findObj(self.current_st)
        while not found and time.time() - self.st < self.total:
            self.control.goTurn(15)
            found = self.vision.findObj(self.current_st)
            print "rotate",self.control.angle,found
            
    def getOutStuck(self):
        """
        out = 1
        while out!=0 and time.time() - self.st < self.total:
            self.control.goTurn(15)
            out = sum(self.control.bumper)
            print "rotate to get out of stuck",self.control.x,self.control.y,self.control.angle,out
        """
        self.control.goStraight(-1)
        time.sleep(2)
        self.control.goTurn(30)
            
            

class Simulator():
    def __init__(self):
        self.bg = Image.new("RGB", (600, 600), (255, 255, 255))            
        #self.circles = [[random.randint(100, 500), random.randint(100, 500), 5, 0] for x in xrange(4)]
        #print self.circles
        self.circles =[[480, 120, 5, 0], [113, 112, 5, 0], [306, 285, 5, 0], [412, 474, 5, 0]]                 
        self.draw = ImageDraw.Draw(self.bg)
        self.st = time.time()
        self.total = 10
        self.player = Logic(self.st,self.total)
        self.ratio=5/self.player.control.width_h
        self.player.start()    
        self.imgs = [Image.new("RGB", (600, 600), (255, 255, 255)) for i in xrange(self.total)] 
        self.bdpt = None
        self.campt = None
        self.cenpt = None
        self.cur = [0, 0, 0]
        
        
    def display(self):
        thres = 0
        tt = time.time()        
        while  tt - self.st < self.total:
            if tt - self.st >= thres:
                self.cur = [self.player.control.x, self.player.control.y, self.player.control.angle]
                self.campt = self.findcarSensor(self.player.control.camangle)
                self.cenpt = self.findcarSensor(self.player.control.eatangle)
                self.player.vision.img = [self.cenpt[0], self.cenpt[1], [self.cur[0], self.cur[1]], self.circles]
                 
                self.findcarCorner()
                print self.bdpt
                self.CheckCollision()
                self.CheckBall()                
                if self.player.control.thrown:
                    self.ThrowBall()                    
                self.drawbg()
                self.drawcar()                
                #print self.cur[0],self.cur[1],thres
                self.imgs[thres] = self.bg.copy()
                self.bg.save(str(thres) + "ha.png", "PNG")
                print "frame", thres
                thres += 1
            tt = time.time()
        
    ########################################## 1. Logic Check       ###############################
    def CheckCollision(self):
        for i in range(4):
            if self.bdpt[i][0] < 100 or self.bdpt[i][0] > 500 or self.bdpt[i][1] < 100 or self.bdpt[i][1] > 500:
                self.player.control.bumper[i] = 1
                delx = self.bdpt[i][0] - 500 + int(self.bdpt[i][0] < 100) * 400
                dely = self.bdpt[i][1] - 500 + int(self.bdpt[i][1] < 100) * 400
                for j in range(4):
                    self.bdpt[j][0] += delx
                    self.bdpt[j][1] += dely
                self.cur[0] += delx
                self.cur[1] += dely
                print "Collision",i,"th bumper sensor"
            else:
                self.player.control.bumper[i] = 0
                

    def CheckBall(self):        
        for i in range(len(self.circles) - 1, -1, -1):
            #print i,[self.bdpt[1],self.bdpt[0],self.bdpt[2]],[self.bdpt[3],self.bdpt[2],self.bdpt[0]]
            if self.circles[i][3]==0 and self.player.vision.ptwithin([self.bdpt[1],self.bdpt[0],self.bdpt[2],self.circles[i][:2]]) and self.player.vision.ptwithin([self.bdpt[3],self.bdpt[2],self.bdpt[0],self.circles[i][:2]]): 
                del self.circles[i]                
                self.player.control.new=1
                print "got it",i                               

    def ThrowBall(self):
        if self.player.ballcount>0:
            throwpt = [(self.bdpt[3][0] + self.bdpt[0][0]) / 2, (self.bdpt[3][1] + self.bdpt[0][0][1]) / 2]
            self.circles.append()[throwpt[0] + 0.1 * (throwpt[0] - self.cur[0]), throwpt[1] + 0.1 * (throwpt[1] - self.cur[1]), 5, 1]
        
    
    ########################################## 2. Plotting Function ###############################
    def drawbg(self):
        #redraw everything
        self.draw.rectangle([100, 100, 500, 500], fill=(255, 255, 255), outline=1)
        self.draw.line([100, 500, 500, 500], fill=(255, 255, 0))
        for i in range(len(self.circles)):
            self.drawcircle(self.circles[i])                               
    
    def drawcircle(self, circle):
        self.draw.setfill(1)
        self.draw.ellipse([circle[0] - circle[2], circle[1] - circle[2], circle[0] + circle[2], circle[1] + circle[2]], fill=(255, 255, 255), outline=128 * (1 - circle[3]))
    
    def drawcar(self):
        #draw body       
        for i in range(3):
            self.draw.line([self.bdpt[i][0], self.bdpt[i][1], self.bdpt[i+1][0], self.bdpt[i+1][1]], fill=0)            
        # the sensor is represented as the red segment at the top        
        self.draw.line([self.bdpt[3][0], self.bdpt[3][1], self.bdpt[0][0], self.bdpt[0][1]], fill=(255, 255, 0))        
        
        #draw sensorline
        self.draw.line([self.cur[0], self.cur[1], self.cenpt[0][0], self.cenpt[0][1]], fill=128)                
        self.draw.line([self.cur[0], self.cur[1], self.cenpt[1][0], self.cenpt[1][1]], fill=128)
        
        self.draw.line([self.cur[0], self.cur[1], self.campt[0][0], self.campt[0][1]], fill=(255, 255, 0))                
        self.draw.line([self.cur[0], self.cur[1], self.campt[1][0], self.campt[1][1]], fill=(255, 255, 0))
        """"""
        
    def findcarCorner(self):
        # the ################
        an = self.cur[2] / 180 * math.pi
        
        rotate = np.matrix([[math.cos(an), -math.sin(an)], [math.sin(an), math.cos(an)]])
        x = self.cur[0]
        y = self.cur[1]
        wh = self.player.control.width_h
        hh = self.player.control.height_h        
        pt = [[[x], [y]] + b for b in [(rotate * [[-wh], [hh]]), (rotate * [[-wh], [-hh]]), (rotate * [[wh], [-hh]]), (rotate * [[wh], [hh]])] ]
        pt2 = [i for b in pt for i in b.tolist()]
        self.bdpt = [[pt2[i][0],pt2[i+1][0]] for i in range(0,len(pt2),2)]
    
    
    #should use vision.findcircle    
    def findcarSensor(self, angle):
        an = [self.cur[2] + angle, self.cur[2] - angle]
        tanan = [math.tan(a / 180 * math.pi) for a in an]                
        pt = [[0, 0]] * 2
        const = [100, 500]        
        for i in xrange(2):
            pp = [0, 0]
            if int(an[i]) % 180 == 0:
                yp = 0                
            else:                                              
                if an[i] < 180:
                    #yp = self.cur[1] + (2*(int(an[i])<90)-1)*(self.cur[0] - 100) / tanan[i]
                    yp = self.cur[1] + (self.cur[0] - 100) / tanan[i]
                else:
                    #yp = self.cur[1] + (2*(int(an[i])>270)-1)*(500 - self.cur[0]) / tanan[i]                                    
                    yp = self.cur[1] - (500 - self.cur[0]) / tanan[i]
                    pp[0] = 1     
                               
            if int(an[i]) % 180 == 90:
                xp = 0
            else:    
                if an[i] < 270 and an[i] > 90:
                    #xp = self.cur[0] + (2*(int(an[i])>180)-1)*tanan[i] * (self.cur[1] - 100)
                    xp = self.cur[0] + tanan[i] * (self.cur[1] - 100)
                else:
                    #xp = self.cur[0] +(2*(int(an[i])<180)-1)*tanan[i] * (500 - self.cur[1])                
                    xp = self.cur[0] - tanan[i] * (500 - self.cur[1])
                    pp[1] = 1
                
            if yp <= 500 and yp >= 100:
                pt[i] = [const[pp[0]], yp]
            else:
                pt[i] = [xp, const[pp[1]]]
        return pt
                

s = Simulator()

s.display()        
Img2Gif.writeGif('haha.gif', s.imgs, duration=0.2, dither=0)

"""
s.cur=[400,400,135]
#print s.findcarSensor(30.0)

#s.cenpt = s.findcarSensor(s.player.control.eatangle)
#s.player.vision.img = [s.cenpt[0], s.cenpt[1], [s.cur[0], s.cur[1]], s.circles]
#print s.player.vision.findObj('r')

s.cur=[301.005050634 ,301.005050634,135]
s.bdpt=[[293.93398282201787, 251.50757595082501], [322.21825406947977, 279.7918471982869], [279.7918471982869, 322.21825406947977], [251.50757595082501, 293.93398282201787]]

#s.cur=[286.86291501, 286.86291501 ,135.0]
#s.bdpt=[[279.7918471982869, 237.36544032709406], [308.0761184457488, 265.64971157455597], [265.64971157455597, 308.0761184457488], [237.36544032709406, 279.7918471982869]]
s.campt = s.findcarSensor(s.player.control.camangle)
s.cenpt = s.findcarSensor(s.player.control.eatangle)
s.drawcar()            
s.drawcircle(s.circles[0])
#s.bg.show()
s.CheckBall()
"""