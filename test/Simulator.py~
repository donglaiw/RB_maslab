from PIL import Image, ImageDraw
import math, random
import numpy as np
import time
import Img2Gif
import sys
sys.append("../Logic/")
import Logic

class Simulator():
    def __init__(self):
        self.bg = Image.new("RGB", (600, 600), (255, 255, 255))            
        #self.circles = [[random.randint(100, 500), random.randint(100, 500), 5, 0] for x in xrange(4)]
        #print self.circles
        self.circles =[[480, 120, 5, 0], [113, 112, 5, 0], [306, 285, 5, 0], [412, 474, 5, 0]]                 
        self.draw = ImageDraw.Draw(self.bg)
        self.st = time.time()
        self.total = 10
        self.player = Logic(self.st,self.total)
        self.ratio=5/self.player.control.width_h
        self.player.start()    
        self.imgs = [Image.new("RGB", (600, 600), (255, 255, 255)) for i in xrange(self.total)] 
        self.bdpt = None
        self.campt = None
        self.cenpt = None
        self.cur = [0, 0, 0]
        
        
    def display(self):
        thres = 0
        tt = time.time()        
        while  tt - self.st < self.total:
            if tt - self.st >= thres:
                self.cur = [self.player.control.x, self.player.control.y, self.player.control.angle]
                self.campt = self.findcarSensor(self.player.control.camangle)
                self.cenpt = self.findcarSensor(self.player.control.eatangle)
                self.player.vision.img = [self.cenpt[0], self.cenpt[1], [self.cur[0], self.cur[1]], self.circles]
                 
                self.findcarCorner()
                print self.bdpt
                self.CheckCollision()
                self.CheckBall()                
                if self.player.control.thrown:
                    self.ThrowBall()                    
                self.drawbg()
                self.drawcar()                
                #print self.cur[0],self.cur[1],thres
                self.imgs[thres] = self.bg.copy()
                self.bg.save(str(thres) + "ha.png", "PNG")
                print "frame", thres
                thres += 1
            tt = time.time()
        
    ########################################## 1. Logic Check       ###############################
    def CheckCollision(self):
        for i in range(4):
            if self.bdpt[i][0] < 100 or self.bdpt[i][0] > 500 or self.bdpt[i][1] < 100 or self.bdpt[i][1] > 500:
                self.player.control.bumper[i] = 1
                delx = self.bdpt[i][0] - 500 + int(self.bdpt[i][0] < 100) * 400
                dely = self.bdpt[i][1] - 500 + int(self.bdpt[i][1] < 100) * 400
                for j in range(4):
                    self.bdpt[j][0] += delx
                    self.bdpt[j][1] += dely
                self.cur[0] += delx
                self.cur[1] += dely
                print "Collision",i,"th bumper sensor"
            else:
                self.player.control.bumper[i] = 0
                

    def CheckBall(self):        
        for i in range(len(self.circles) - 1, -1, -1):
            #print i,[self.bdpt[1],self.bdpt[0],self.bdpt[2]],[self.bdpt[3],self.bdpt[2],self.bdpt[0]]
            if self.circles[i][3]==0 and self.player.vision.ptwithin([self.bdpt[1],self.bdpt[0],self.bdpt[2],self.circles[i][:2]]) and self.player.vision.ptwithin([self.bdpt[3],self.bdpt[2],self.bdpt[0],self.circles[i][:2]]): 
                del self.circles[i]                
                self.player.control.new=1
                print "got it",i                               

    def ThrowBall(self):
        if self.player.ballcount>0:
            throwpt = [(self.bdpt[3][0] + self.bdpt[0][0]) / 2, (self.bdpt[3][1] + self.bdpt[0][0][1]) / 2]
            self.circles.append()[throwpt[0] + 0.1 * (throwpt[0] - self.cur[0]), throwpt[1] + 0.1 * (throwpt[1] - self.cur[1]), 5, 1]
        
    
    ########################################## 2. Plotting Function ###############################
    def drawbg(self):
        #redraw everything
        self.draw.rectangle([100, 100, 500, 500], fill=(255, 255, 255), outline=1)
        self.draw.line([100, 500, 500, 500], fill=(255, 255, 0))
        for i in range(len(self.circles)):
            self.drawcircle(self.circles[i])                               
    
    def drawcircle(self, circle):
        self.draw.setfill(1)
        self.draw.ellipse([circle[0] - circle[2], circle[1] - circle[2], circle[0] + circle[2], circle[1] + circle[2]], fill=(255, 255, 255), outline=128 * (1 - circle[3]))
    
    def drawcar(self):
        #draw body       
        for i in range(3):
            self.draw.line([self.bdpt[i][0], self.bdpt[i][1], self.bdpt[i+1][0], self.bdpt[i+1][1]], fill=0)            
        # the sensor is represented as the red segment at the top        
        self.draw.line([self.bdpt[3][0], self.bdpt[3][1], self.bdpt[0][0], self.bdpt[0][1]], fill=(255, 255, 0))        
        
        #draw sensorline
        self.draw.line([self.cur[0], self.cur[1], self.cenpt[0][0], self.cenpt[0][1]], fill=128)                
        self.draw.line([self.cur[0], self.cur[1], self.cenpt[1][0], self.cenpt[1][1]], fill=128)
        
        self.draw.line([self.cur[0], self.cur[1], self.campt[0][0], self.campt[0][1]], fill=(255, 255, 0))                
        self.draw.line([self.cur[0], self.cur[1], self.campt[1][0], self.campt[1][1]], fill=(255, 255, 0))
        """"""
        
    def findcarCorner(self):
        # the ################
        an = self.cur[2] / 180 * math.pi
        
        rotate = np.matrix([[math.cos(an), -math.sin(an)], [math.sin(an), math.cos(an)]])
        x = self.cur[0]
        y = self.cur[1]
        wh = self.player.control.width_h
        hh = self.player.control.height_h        
        pt = [[[x], [y]] + b for b in [(rotate * [[-wh], [hh]]), (rotate * [[-wh], [-hh]]), (rotate * [[wh], [-hh]]), (rotate * [[wh], [hh]])] ]
        pt2 = [i for b in pt for i in b.tolist()]
        self.bdpt = [[pt2[i][0],pt2[i+1][0]] for i in range(0,len(pt2),2)]
    
    
    #should use vision.findcircle    
    def findcarSensor(self, angle):
        an = [self.cur[2] + angle, self.cur[2] - angle]
        tanan = [math.tan(a / 180 * math.pi) for a in an]                
        pt = [[0, 0]] * 2
        const = [100, 500]        
        for i in xrange(2):
            pp = [0, 0]
            if int(an[i]) % 180 == 0:
                yp = 0                
            else:                                              
                if an[i] < 180:
                    #yp = self.cur[1] + (2*(int(an[i])<90)-1)*(self.cur[0] - 100) / tanan[i]
                    yp = self.cur[1] + (self.cur[0] - 100) / tanan[i]
                else:
                    #yp = self.cur[1] + (2*(int(an[i])>270)-1)*(500 - self.cur[0]) / tanan[i]                                    
                    yp = self.cur[1] - (500 - self.cur[0]) / tanan[i]
                    pp[0] = 1     
                               
            if int(an[i]) % 180 == 90:
                xp = 0
            else:    
                if an[i] < 270 and an[i] > 90:
                    #xp = self.cur[0] + (2*(int(an[i])>180)-1)*tanan[i] * (self.cur[1] - 100)
                    xp = self.cur[0] + tanan[i] * (self.cur[1] - 100)
                else:
                    #xp = self.cur[0] +(2*(int(an[i])<180)-1)*tanan[i] * (500 - self.cur[1])                
                    xp = self.cur[0] - tanan[i] * (500 - self.cur[1])
                    pp[1] = 1
                
            if yp <= 500 and yp >= 100:
                pt[i] = [const[pp[0]], yp]
            else:
                pt[i] = [xp, const[pp[1]]]
        return pt
                

s = Simulator()

s.display()        
Img2Gif.writeGif('haha.gif', s.imgs, duration=0.2, dither=0)

"""
s.cur=[400,400,135]
#print s.findcarSensor(30.0)

#s.cenpt = s.findcarSensor(s.player.control.eatangle)
#s.player.vision.img = [s.cenpt[0], s.cenpt[1], [s.cur[0], s.cur[1]], s.circles]
#print s.player.vision.findObj('r')

s.cur=[301.005050634 ,301.005050634,135]
s.bdpt=[[293.93398282201787, 251.50757595082501], [322.21825406947977, 279.7918471982869], [279.7918471982869, 322.21825406947977], [251.50757595082501, 293.93398282201787]]

#s.cur=[286.86291501, 286.86291501 ,135.0]
#s.bdpt=[[279.7918471982869, 237.36544032709406], [308.0761184457488, 265.64971157455597], [265.64971157455597, 308.0761184457488], [237.36544032709406, 279.7918471982869]]
s.campt = s.findcarSensor(s.player.control.camangle)
s.cenpt = s.findcarSensor(s.player.control.eatangle)
s.drawcar()            
s.drawcircle(s.circles[0])
#s.bg.show()
s.CheckBall()
"""
